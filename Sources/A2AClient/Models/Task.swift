// Task.swift
// A2AClient
//
// Agent2Agent Protocol - Task Definitions

import Foundation

/// Represents a unit of work in the A2A protocol.
///
/// Tasks are the fundamental unit of work managed by A2A. They are stateful,
/// progress through a defined lifecycle, and can produce artifacts as outputs.
public struct A2ATask: Codable, Sendable, Equatable, Identifiable {
    /// Unique identifier for this task (server-generated).
    public let id: String

    /// Context identifier grouping related tasks and messages.
    public let contextId: String

    /// Current status of the task.
    public let status: TaskStatus

    /// Output artifacts generated by this task.
    public let artifacts: [Artifact]?

    /// History of messages exchanged during this task.
    public let history: [Message]?

    /// Optional metadata associated with this task.
    public let metadata: [String: AnyCodable]?

    public init(
        id: String,
        contextId: String,
        status: TaskStatus,
        artifacts: [Artifact]? = nil,
        history: [Message]? = nil,
        metadata: [String: AnyCodable]? = nil
    ) {
        self.id = id
        self.contextId = contextId
        self.status = status
        self.artifacts = artifacts
        self.history = history
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case contextId = "context_id"
        case status
        case artifacts
        case history
        case metadata
    }
}

// MARK: - Task Convenience Extensions

extension A2ATask {
    /// The current state of the task.
    public var state: TaskState {
        status.state
    }

    /// Whether the task is in a terminal (final) state.
    public var isComplete: Bool {
        status.state.isTerminal
    }

    /// Whether the task is waiting for input.
    public var needsInput: Bool {
        status.state.canReceiveInput
    }

    /// Returns the most recent message in the task history.
    public var lastMessage: Message? {
        history?.last
    }

    /// Returns all user messages from the task history.
    public var userMessages: [Message] {
        history?.filter { $0.role == .user } ?? []
    }

    /// Returns all agent messages from the task history.
    public var agentMessages: [Message] {
        history?.filter { $0.role == .agent } ?? []
    }
}

// MARK: - TaskIdParams

/// Parameters for identifying a task.
public struct TaskIdParams: Codable, Sendable, Equatable {
    /// Optional tenant identifier.
    public let tenant: String?

    /// The task identifier.
    public let id: String

    /// Maximum number of messages to include in history.
    public let historyLength: Int?

    public init(tenant: String? = nil, id: String, historyLength: Int? = nil) {
        self.tenant = tenant
        self.id = id
        self.historyLength = historyLength
    }

    private enum CodingKeys: String, CodingKey {
        case tenant
        case id
        case historyLength = "history_length"
    }
}

// MARK: - TaskQueryParams

/// Parameters for listing tasks with optional filtering and pagination.
public struct TaskQueryParams: Codable, Sendable, Equatable {
    /// Optional tenant identifier.
    public let tenant: String?

    /// Filter tasks by context ID.
    public let contextId: String?

    /// Filter tasks by their current status state.
    public let status: TaskState?

    /// Maximum number of tasks to return (1-100, default 50).
    public let pageSize: Int?

    /// Token for pagination from previous response.
    public let pageToken: String?

    /// Maximum number of messages to include in each task's history.
    public let historyLength: Int?

    /// Filter tasks with status timestamp after this date (ISO 8601).
    public let statusTimestampAfter: Date?

    /// Whether to include artifacts in returned tasks (default false).
    public let includeArtifacts: Bool?

    public init(
        tenant: String? = nil,
        contextId: String? = nil,
        status: TaskState? = nil,
        pageSize: Int? = nil,
        pageToken: String? = nil,
        historyLength: Int? = nil,
        statusTimestampAfter: Date? = nil,
        includeArtifacts: Bool? = nil
    ) {
        self.tenant = tenant
        self.contextId = contextId
        self.status = status
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.historyLength = historyLength
        self.statusTimestampAfter = statusTimestampAfter
        self.includeArtifacts = includeArtifacts
    }

    private enum CodingKeys: String, CodingKey {
        case tenant
        case contextId = "context_id"
        case status
        case pageSize = "page_size"
        case pageToken = "page_token"
        case historyLength = "history_length"
        case statusTimestampAfter = "status_timestamp_after"
        case includeArtifacts = "include_artifacts"
    }
}

// MARK: - TaskListResponse

/// Response from listing tasks.
public struct TaskListResponse: Codable, Sendable, Equatable {
    /// Array of tasks matching the criteria.
    public let tasks: [A2ATask]

    /// Token for retrieving the next page. Empty string if no more results.
    public let nextPageToken: String

    /// The page size requested.
    public let pageSize: Int

    /// Total number of tasks available (before pagination).
    public let totalSize: Int

    public init(
        tasks: [A2ATask],
        nextPageToken: String = "",
        pageSize: Int = 50,
        totalSize: Int = 0
    ) {
        self.tasks = tasks
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.totalSize = totalSize
    }

    private enum CodingKeys: String, CodingKey {
        case tasks
        case nextPageToken = "next_page_token"
        case pageSize = "page_size"
        case totalSize = "total_size"
    }
}
