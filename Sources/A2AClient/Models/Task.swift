// Task.swift
// A2AClient
//
// Agent2Agent Protocol - Task Definitions

import Foundation

/// Represents a unit of work in the A2A protocol.
///
/// Tasks are the fundamental unit of work managed by A2A. They are stateful,
/// progress through a defined lifecycle, and can produce artifacts as outputs.
public struct A2ATask: Codable, Sendable, Equatable, Identifiable {
    /// Unique identifier for this task (server-generated).
    public let id: String

    /// Context identifier grouping related tasks and messages.
    public let contextId: String

    /// Current status of the task.
    public let status: TaskStatus

    /// Output artifacts generated by this task.
    public let artifacts: [Artifact]?

    /// History of messages exchanged during this task.
    public let history: [Message]?

    /// Optional metadata associated with this task.
    public let metadata: [String: AnyCodable]?

    /// The type of task (optional, for categorization).
    public let kind: String?

    public init(
        id: String,
        contextId: String,
        status: TaskStatus,
        artifacts: [Artifact]? = nil,
        history: [Message]? = nil,
        metadata: [String: AnyCodable]? = nil,
        kind: String? = nil
    ) {
        self.id = id
        self.contextId = contextId
        self.status = status
        self.artifacts = artifacts
        self.history = history
        self.metadata = metadata
        self.kind = kind
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case contextId = "context_id"
        case status
        case artifacts
        case history
        case metadata
        case kind
    }
}

// MARK: - Task Convenience Extensions

extension A2ATask {
    /// The current state of the task.
    public var state: TaskState {
        status.state
    }

    /// Whether the task is in a terminal (final) state.
    public var isComplete: Bool {
        status.state.isTerminal
    }

    /// Whether the task is waiting for input.
    public var needsInput: Bool {
        status.state.canReceiveInput
    }

    /// Returns the most recent message in the task history.
    public var lastMessage: Message? {
        history?.last
    }

    /// Returns all user messages from the task history.
    public var userMessages: [Message] {
        history?.filter { $0.role == .user } ?? []
    }

    /// Returns all agent messages from the task history.
    public var agentMessages: [Message] {
        history?.filter { $0.role == .agent } ?? []
    }
}

// MARK: - TaskIdParams

/// Parameters for identifying a task.
public struct TaskIdParams: Codable, Sendable, Equatable {
    /// The task identifier.
    public let id: String

    /// Optional metadata for the request.
    public let metadata: [String: AnyCodable]?

    public init(id: String, metadata: [String: AnyCodable]? = nil) {
        self.id = id
        self.metadata = metadata
    }
}

// MARK: - TaskQueryParams

/// Parameters for querying tasks.
public struct TaskQueryParams: Codable, Sendable, Equatable {
    /// Optional context ID to filter by.
    public let contextId: String?

    /// Optional list of task states to filter by.
    public let states: [TaskState]?

    /// Maximum number of tasks to return.
    public let limit: Int?

    /// Pagination cursor for fetching next page.
    public let cursor: String?

    /// Optional metadata for the request.
    public let metadata: [String: AnyCodable]?

    public init(
        contextId: String? = nil,
        states: [TaskState]? = nil,
        limit: Int? = nil,
        cursor: String? = nil,
        metadata: [String: AnyCodable]? = nil
    ) {
        self.contextId = contextId
        self.states = states
        self.limit = limit
        self.cursor = cursor
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case contextId = "context_id"
        case states
        case limit
        case cursor
        case metadata
    }
}

// MARK: - TaskListResponse

/// Response from listing tasks.
public struct TaskListResponse: Codable, Sendable, Equatable {
    /// The list of tasks.
    public let tasks: [A2ATask]

    /// Pagination cursor for fetching next page.
    public let nextCursor: String?

    public init(tasks: [A2ATask], nextCursor: String? = nil) {
        self.tasks = tasks
        self.nextCursor = nextCursor
    }

    private enum CodingKeys: String, CodingKey {
        case tasks
        case nextCursor = "next_cursor"
    }
}
